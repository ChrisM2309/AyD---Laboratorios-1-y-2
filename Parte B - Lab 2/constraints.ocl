constraints

-- 3 invariantes  

-- 1. Estado valido de reserva

context Reserva
  inv EstadoValido:
    Set{ EstadoReserva::CREADA,
         EstadoReserva::CONFIRMADA,
         EstadoReserva::CANCELADA,
         EstadoReserva::EXPIRADA }->includes(self.estado)

-- 2. Cardinalidad logica - un tutor y un estudiante

context Reserva
  inv TieneTutorYEstudiante:
    not self.tutor.oclIsUndefined() and not self.estudiante.oclIsUndefined()

-- 3. Unicidad -- no puede tener mas de 1 reserva al mismo tiempo 

context Tutor
  inv NoDobleReservaActivaMismoHorario:
    self.reservas
      ->select(r | r.estado <> EstadoReserva::CANCELADA and r.estado <> EstadoReserva::EXPIRADA)
      ->isUnique(r | r.fechaHora)


-- Precondiciones para crear/cancelar

-- 1. Crear --> existir disponibilidad libre y no violar Unicidad

context ReservaService::crearReserva(estudiante : Estudiante, tutor : Tutor, fechaHora : String) : Reserva
  pre PuedeCrearReserva:
    tutor.disponibilidades->exists(d | 
      d.fechaHora = fechaHora and d.estado = EstadoDisponibilidad::LIBRE
    )
    and
    tutor.reservas
      ->select(r | r.estado <> EstadoReserva::CANCELADA and r.estado <> EstadoReserva::EXPIRADA)
      ->forAll(r | r.fechaHora <> fechaHora)

-- 2. Cancelar --> solo cancelar si esta activo 

context ReservaService::cancelarReserva(reserva : Reserva)
  pre PuedeCancelar:
    reserva.estado = EstadoReserva::CREADA or reserva.estado = EstadoReserva::CONFIRMADA

-- Postcondiciones

-- 1. Al crear una reserva, su estado es creada y tiene un tutor + estudiante 

context ReservaService::crearReserva(estudiante : Estudiante, tutor : Tutor, fechaHora : String) : Reserva
  post ReservaQuedaCreada:
    result.estado = EstadoReserva::CREADA and
    result.fechaHora = fechaHora and
    result.tutor = tutor and
    result.estudiante = estudiante